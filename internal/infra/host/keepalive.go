//go:build darwin

package host

import (
	"fmt"
	"os"
	"os/exec"
	osuser "os/user"
	"path/filepath"
	"strconv"
)

const (
	keepaliveLabel    = "com.imessage.keepalive"
	keepaliveInterval = 600 // 10 minutes
)

// Keepalive shell script template that reads chat.db and triggers imagent XPC.
const keepaliveScriptTemplate = `#!/bin/bash
# iMessage Keepalive Script - Auto-generated by Prism

LOG_FILE="$HOME/Library/Logs/imessage-keepalive.log"

log() {
    echo "[$(date '+%%Y-%%m-%%d %%H:%%M:%%S')] $1" >> "$LOG_FILE"
}

keepalive() {
    log "====== Keepalive cycle ======"

    # 1. Read chat.db to keep iMessage active
    chat_db="$HOME/Library/Messages/chat.db"
    if [ -f "$chat_db" ]; then
        /usr/bin/sqlite3 "$chat_db" "SELECT MAX(ROWID) FROM message;" > /dev/null 2>&1
        log "DB read complete"
    fi

    # 2. Trigger imagent XPC
    /bin/launchctl print gui/$(id -u)/com.apple.imagent > /dev/null 2>&1
    log "XPC trigger complete"

    log "====== Cycle complete ======"
}

log "Starting keepalive service (interval: %d seconds)"

while true; do
    keepalive
    sleep %d
done
`

// LaunchAgent plist template for keepalive service.
// Must be LaunchAgent (not LaunchDaemon) because it needs GUI session.
const keepaliveLaunchAgentTemplate = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.imessage.keepalive</string>
    <key>ProgramArguments</key>
    <array>
        <string>%s</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>%s</string>
    <key>StandardErrorPath</key>
    <string>%s</string>
</dict>
</plist>
`

// EnsureKeepaliveService deploys the keepalive script and LaunchAgent for a user.
// This is idempotent - it will overwrite existing files to ensure latest version.
func EnsureKeepaliveService(username string) error {
	homeDir := filepath.Join("/Users", username)
	scriptPath := filepath.Join(homeDir, "imessage-keepalive.sh")
	launchAgentsDir := filepath.Join(homeDir, "Library", "LaunchAgents")
	plistPath := filepath.Join(launchAgentsDir, keepaliveLabel+".plist")
	logsDir := filepath.Join(homeDir, "Library", "Logs")

	// Get user UID for launchctl
	uid, err := getUserUID(username)
	if err != nil {
		return fmt.Errorf("get user UID: %w", err)
	}

	// Ensure directories exist
	if err := os.MkdirAll(launchAgentsDir, 0o755); err != nil {
		return fmt.Errorf("create LaunchAgents dir: %w", err)
	}
	if err := chownRecursive(username, launchAgentsDir); err != nil {
		return fmt.Errorf("chown LaunchAgents dir: %w", err)
	}

	if err := os.MkdirAll(logsDir, 0o755); err != nil {
		return fmt.Errorf("create Logs dir: %w", err)
	}
	if err := chownRecursive(username, logsDir); err != nil {
		return fmt.Errorf("chown Logs dir: %w", err)
	}

	// Write keepalive script
	scriptContent := fmt.Sprintf(keepaliveScriptTemplate, keepaliveInterval, keepaliveInterval)
	if err := os.WriteFile(scriptPath, []byte(scriptContent), 0o755); err != nil {
		return fmt.Errorf("write keepalive script: %w", err)
	}

	// Fix ownership
	if err := chownRecursive(username, scriptPath); err != nil {
		return fmt.Errorf("chown script: %w", err)
	}

	// Write LaunchAgent plist
	stdoutLog := filepath.Join(logsDir, "imessage-keepalive-stdout.log")
	stderrLog := filepath.Join(logsDir, "imessage-keepalive-stderr.log")
	plistContent := fmt.Sprintf(keepaliveLaunchAgentTemplate, scriptPath, stdoutLog, stderrLog)
	if err := os.WriteFile(plistPath, []byte(plistContent), 0o644); err != nil {
		return fmt.Errorf("write keepalive plist: %w", err)
	}

	// Fix ownership of plist
	if err := chownRecursive(username, plistPath); err != nil {
		return fmt.Errorf("chown plist: %w", err)
	}

	// Bootstrap the LaunchAgent if not already loaded
	// Note: This requires the user to have an active GUI session
	domain := fmt.Sprintf("gui/%d", uid)
	serviceTarget := fmt.Sprintf("%s/%s", domain, keepaliveLabel)

	// Bootout first to ensure reload
	_ = exec.Command("launchctl", "bootout", serviceTarget).Run()

	if err := exec.Command("launchctl", "bootstrap", domain, plistPath).Run(); err != nil {
		// Not an error - user might not have GUI session yet
		// Service will start automatically when user logs in (RunAtLoad)
		return nil
	}

	return nil
}

// getUserUID returns the numeric UID for a username.
func getUserUID(username string) (int, error) {
	u, err := osuser.Lookup(username)
	if err != nil {
		return 0, fmt.Errorf("lookup user %s: %w", username, err)
	}
	uid, err := strconv.Atoi(u.Uid)
	if err != nil {
		return 0, fmt.Errorf("parse UID %s: %w", u.Uid, err)
	}
	return uid, nil
}
